// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef INFORMATIONAFTERDIVE_TYPE_HXX
#define INFORMATIONAFTERDIVE_TYPE_HXX

#include "informationafterdiveType-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "surfaceintervalType-fwd.hxx"

#include "current-fwd.hxx"

#include "diveplan-fwd.hxx"

#include "equipmentmalfunction-fwd.hxx"

#include "problems-fwd.hxx"

#include "program-fwd.hxx"

#include "thermalcomfort-fwd.hxx"

#include "workload-fwd.hxx"

#include "notesType-fwd.hxx"

#include "ratingType-fwd.hxx"

#include "anysymptoms-fwd.hxx"

#include "divetable-fwd.hxx"

#include "globalalarmsgiven-fwd.hxx"

#include "observationsType-fwd.hxx"

namespace streit
{
  class informationafterdiveType: public ::xml_schema::type
  {
    public:
    // surfaceintervalafterdive
    //
    typedef ::streit::surfaceintervalType surfaceintervalafterdive_type;
    typedef ::xsd::cxx::tree::optional< surfaceintervalafterdive_type > surfaceintervalafterdive_optional;
    typedef ::xsd::cxx::tree::traits< surfaceintervalafterdive_type, char > surfaceintervalafterdive_traits;

    const surfaceintervalafterdive_optional&
    surfaceintervalafterdive () const;

    surfaceintervalafterdive_optional&
    surfaceintervalafterdive ();

    void
    surfaceintervalafterdive (const surfaceintervalafterdive_type& x);

    void
    surfaceintervalafterdive (const surfaceintervalafterdive_optional& x);

    void
    surfaceintervalafterdive (::std::unique_ptr< surfaceintervalafterdive_type > p);

    // lowesttemperature
    //
    typedef ::xml_schema::float_ lowesttemperature_type;
    typedef ::xsd::cxx::tree::optional< lowesttemperature_type > lowesttemperature_optional;
    typedef ::xsd::cxx::tree::traits< lowesttemperature_type, char > lowesttemperature_traits;

    const lowesttemperature_optional&
    lowesttemperature () const;

    lowesttemperature_optional&
    lowesttemperature ();

    void
    lowesttemperature (const lowesttemperature_type& x);

    void
    lowesttemperature (const lowesttemperature_optional& x);

    // greatestdepth
    //
    typedef ::xml_schema::float_ greatestdepth_type;
    typedef ::xsd::cxx::tree::traits< greatestdepth_type, char > greatestdepth_traits;

    const greatestdepth_type&
    greatestdepth () const;

    greatestdepth_type&
    greatestdepth ();

    void
    greatestdepth (const greatestdepth_type& x);

    // visibility
    //
    typedef ::xml_schema::float_ visibility_type;
    typedef ::xsd::cxx::tree::optional< visibility_type > visibility_optional;
    typedef ::xsd::cxx::tree::traits< visibility_type, char > visibility_traits;

    const visibility_optional&
    visibility () const;

    visibility_optional&
    visibility ();

    void
    visibility (const visibility_type& x);

    void
    visibility (const visibility_optional& x);

    // current
    //
    typedef ::streit::current current_type;
    typedef ::xsd::cxx::tree::optional< current_type > current_optional;
    typedef ::xsd::cxx::tree::traits< current_type, char > current_traits;

    const current_optional&
    current () const;

    current_optional&
    current ();

    void
    current (const current_type& x);

    void
    current (const current_optional& x);

    void
    current (::std::unique_ptr< current_type > p);

    // diveplan
    //
    typedef ::streit::diveplan diveplan_type;
    typedef ::xsd::cxx::tree::optional< diveplan_type > diveplan_optional;
    typedef ::xsd::cxx::tree::traits< diveplan_type, char > diveplan_traits;

    const diveplan_optional&
    diveplan () const;

    diveplan_optional&
    diveplan ();

    void
    diveplan (const diveplan_type& x);

    void
    diveplan (const diveplan_optional& x);

    void
    diveplan (::std::unique_ptr< diveplan_type > p);

    // equipmentmalfunction
    //
    typedef ::streit::equipmentmalfunction equipmentmalfunction_type;
    typedef ::xsd::cxx::tree::optional< equipmentmalfunction_type > equipmentmalfunction_optional;
    typedef ::xsd::cxx::tree::traits< equipmentmalfunction_type, char > equipmentmalfunction_traits;

    const equipmentmalfunction_optional&
    equipmentmalfunction () const;

    equipmentmalfunction_optional&
    equipmentmalfunction ();

    void
    equipmentmalfunction (const equipmentmalfunction_type& x);

    void
    equipmentmalfunction (const equipmentmalfunction_optional& x);

    void
    equipmentmalfunction (::std::unique_ptr< equipmentmalfunction_type > p);

    // pressuredrop
    //
    typedef ::xml_schema::float_ pressuredrop_type;
    typedef ::xsd::cxx::tree::optional< pressuredrop_type > pressuredrop_optional;
    typedef ::xsd::cxx::tree::traits< pressuredrop_type, char > pressuredrop_traits;

    const pressuredrop_optional&
    pressuredrop () const;

    pressuredrop_optional&
    pressuredrop ();

    void
    pressuredrop (const pressuredrop_type& x);

    void
    pressuredrop (const pressuredrop_optional& x);

    // problems
    //
    typedef ::streit::problems problems_type;
    typedef ::xsd::cxx::tree::optional< problems_type > problems_optional;
    typedef ::xsd::cxx::tree::traits< problems_type, char > problems_traits;

    const problems_optional&
    problems () const;

    problems_optional&
    problems ();

    void
    problems (const problems_type& x);

    void
    problems (const problems_optional& x);

    void
    problems (::std::unique_ptr< problems_type > p);

    // program
    //
    typedef ::streit::program program_type;
    typedef ::xsd::cxx::tree::optional< program_type > program_optional;
    typedef ::xsd::cxx::tree::traits< program_type, char > program_traits;

    const program_optional&
    program () const;

    program_optional&
    program ();

    void
    program (const program_type& x);

    void
    program (const program_optional& x);

    void
    program (::std::unique_ptr< program_type > p);

    // thermalcomfort
    //
    typedef ::streit::thermalcomfort thermalcomfort_type;
    typedef ::xsd::cxx::tree::optional< thermalcomfort_type > thermalcomfort_optional;
    typedef ::xsd::cxx::tree::traits< thermalcomfort_type, char > thermalcomfort_traits;

    const thermalcomfort_optional&
    thermalcomfort () const;

    thermalcomfort_optional&
    thermalcomfort ();

    void
    thermalcomfort (const thermalcomfort_type& x);

    void
    thermalcomfort (const thermalcomfort_optional& x);

    void
    thermalcomfort (::std::unique_ptr< thermalcomfort_type > p);

    // workload
    //
    typedef ::streit::workload workload_type;
    typedef ::xsd::cxx::tree::optional< workload_type > workload_optional;
    typedef ::xsd::cxx::tree::traits< workload_type, char > workload_traits;

    const workload_optional&
    workload () const;

    workload_optional&
    workload ();

    void
    workload (const workload_type& x);

    void
    workload (const workload_optional& x);

    void
    workload (::std::unique_ptr< workload_type > p);

    // desaturationtime
    //
    typedef ::xml_schema::float_ desaturationtime_type;
    typedef ::xsd::cxx::tree::optional< desaturationtime_type > desaturationtime_optional;
    typedef ::xsd::cxx::tree::traits< desaturationtime_type, char > desaturationtime_traits;

    const desaturationtime_optional&
    desaturationtime () const;

    desaturationtime_optional&
    desaturationtime ();

    void
    desaturationtime (const desaturationtime_type& x);

    void
    desaturationtime (const desaturationtime_optional& x);

    // noflighttime
    //
    typedef ::xml_schema::float_ noflighttime_type;
    typedef ::xsd::cxx::tree::optional< noflighttime_type > noflighttime_optional;
    typedef ::xsd::cxx::tree::traits< noflighttime_type, char > noflighttime_traits;

    const noflighttime_optional&
    noflighttime () const;

    noflighttime_optional&
    noflighttime ();

    void
    noflighttime (const noflighttime_type& x);

    void
    noflighttime (const noflighttime_optional& x);

    // notes
    //
    typedef ::streit::notesType notes_type;
    typedef ::xsd::cxx::tree::optional< notes_type > notes_optional;
    typedef ::xsd::cxx::tree::traits< notes_type, char > notes_traits;

    const notes_optional&
    notes () const;

    notes_optional&
    notes ();

    void
    notes (const notes_type& x);

    void
    notes (const notes_optional& x);

    void
    notes (::std::unique_ptr< notes_type > p);

    // rating
    //
    typedef ::streit::ratingType rating_type;
    typedef ::xsd::cxx::tree::optional< rating_type > rating_optional;
    typedef ::xsd::cxx::tree::traits< rating_type, char > rating_traits;

    const rating_optional&
    rating () const;

    rating_optional&
    rating ();

    void
    rating (const rating_type& x);

    void
    rating (const rating_optional& x);

    void
    rating (::std::unique_ptr< rating_type > p);

    // anysymptoms
    //
    typedef ::streit::anysymptoms anysymptoms_type;
    typedef ::xsd::cxx::tree::optional< anysymptoms_type > anysymptoms_optional;
    typedef ::xsd::cxx::tree::traits< anysymptoms_type, char > anysymptoms_traits;

    const anysymptoms_optional&
    anysymptoms () const;

    anysymptoms_optional&
    anysymptoms ();

    void
    anysymptoms (const anysymptoms_type& x);

    void
    anysymptoms (const anysymptoms_optional& x);

    void
    anysymptoms (::std::unique_ptr< anysymptoms_type > p);

    // diveduration
    //
    typedef ::xml_schema::float_ diveduration_type;
    typedef ::xsd::cxx::tree::traits< diveduration_type, char > diveduration_traits;

    const diveduration_type&
    diveduration () const;

    diveduration_type&
    diveduration ();

    void
    diveduration (const diveduration_type& x);

    // divetable
    //
    typedef ::streit::divetable divetable_type;
    typedef ::xsd::cxx::tree::optional< divetable_type > divetable_optional;
    typedef ::xsd::cxx::tree::traits< divetable_type, char > divetable_traits;

    const divetable_optional&
    divetable () const;

    divetable_optional&
    divetable ();

    void
    divetable (const divetable_type& x);

    void
    divetable (const divetable_optional& x);

    void
    divetable (::std::unique_ptr< divetable_type > p);

    // globalalarmsgiven
    //
    typedef ::streit::globalalarmsgiven globalalarmsgiven_type;
    typedef ::xsd::cxx::tree::optional< globalalarmsgiven_type > globalalarmsgiven_optional;
    typedef ::xsd::cxx::tree::traits< globalalarmsgiven_type, char > globalalarmsgiven_traits;

    const globalalarmsgiven_optional&
    globalalarmsgiven () const;

    globalalarmsgiven_optional&
    globalalarmsgiven ();

    void
    globalalarmsgiven (const globalalarmsgiven_type& x);

    void
    globalalarmsgiven (const globalalarmsgiven_optional& x);

    void
    globalalarmsgiven (::std::unique_ptr< globalalarmsgiven_type > p);

    // highestpo2
    //
    typedef ::xml_schema::float_ highestpo2_type;
    typedef ::xsd::cxx::tree::optional< highestpo2_type > highestpo2_optional;
    typedef ::xsd::cxx::tree::traits< highestpo2_type, char > highestpo2_traits;

    const highestpo2_optional&
    highestpo2 () const;

    highestpo2_optional&
    highestpo2 ();

    void
    highestpo2 (const highestpo2_type& x);

    void
    highestpo2 (const highestpo2_optional& x);

    // observations
    //
    typedef ::streit::observationsType observations_type;
    typedef ::xsd::cxx::tree::optional< observations_type > observations_optional;
    typedef ::xsd::cxx::tree::traits< observations_type, char > observations_traits;

    const observations_optional&
    observations () const;

    observations_optional&
    observations ();

    void
    observations (const observations_type& x);

    void
    observations (const observations_optional& x);

    void
    observations (::std::unique_ptr< observations_type > p);

    // averagedepth
    //
    typedef ::xml_schema::float_ averagedepth_type;
    typedef ::xsd::cxx::tree::optional< averagedepth_type > averagedepth_optional;
    typedef ::xsd::cxx::tree::traits< averagedepth_type, char > averagedepth_traits;

    const averagedepth_optional&
    averagedepth () const;

    averagedepth_optional&
    averagedepth ();

    void
    averagedepth (const averagedepth_type& x);

    void
    averagedepth (const averagedepth_optional& x);

    // Constructors.
    //
    informationafterdiveType (const greatestdepth_type&,
                              const diveduration_type&);

    informationafterdiveType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    informationafterdiveType (const informationafterdiveType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual informationafterdiveType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    informationafterdiveType&
    operator= (const informationafterdiveType& x);

    virtual 
    ~informationafterdiveType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    surfaceintervalafterdive_optional surfaceintervalafterdive_;
    lowesttemperature_optional lowesttemperature_;
    ::xsd::cxx::tree::one< greatestdepth_type > greatestdepth_;
    visibility_optional visibility_;
    current_optional current_;
    diveplan_optional diveplan_;
    equipmentmalfunction_optional equipmentmalfunction_;
    pressuredrop_optional pressuredrop_;
    problems_optional problems_;
    program_optional program_;
    thermalcomfort_optional thermalcomfort_;
    workload_optional workload_;
    desaturationtime_optional desaturationtime_;
    noflighttime_optional noflighttime_;
    notes_optional notes_;
    rating_optional rating_;
    anysymptoms_optional anysymptoms_;
    ::xsd::cxx::tree::one< diveduration_type > diveduration_;
    divetable_optional divetable_;
    globalalarmsgiven_optional globalalarmsgiven_;
    highestpo2_optional highestpo2_;
    observations_optional observations_;
    averagedepth_optional averagedepth_;
  };
}

#include <iosfwd>

namespace streit
{
  ::std::ostream&
  operator<< (::std::ostream&, const informationafterdiveType&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace streit
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // INFORMATIONAFTERDIVE_TYPE_HXX
