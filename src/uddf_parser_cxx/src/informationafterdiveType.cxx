// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "informationafterdiveType.hxx"

#include "surfaceintervalType.hxx"

#include "current.hxx"

#include "diveplan.hxx"

#include "equipmentmalfunction.hxx"

#include "problems.hxx"

#include "program.hxx"

#include "thermalcomfort.hxx"

#include "workload.hxx"

#include "notesType.hxx"

#include "ratingType.hxx"

#include "anysymptoms.hxx"

#include "divetable.hxx"

#include "globalalarmsgiven.hxx"

#include "observationsType.hxx"

namespace streit
{
  // informationafterdiveType
  //

  const informationafterdiveType::surfaceintervalafterdive_optional& informationafterdiveType::
  surfaceintervalafterdive () const
  {
    return this->surfaceintervalafterdive_;
  }

  informationafterdiveType::surfaceintervalafterdive_optional& informationafterdiveType::
  surfaceintervalafterdive ()
  {
    return this->surfaceintervalafterdive_;
  }

  void informationafterdiveType::
  surfaceintervalafterdive (const surfaceintervalafterdive_type& x)
  {
    this->surfaceintervalafterdive_.set (x);
  }

  void informationafterdiveType::
  surfaceintervalafterdive (const surfaceintervalafterdive_optional& x)
  {
    this->surfaceintervalafterdive_ = x;
  }

  void informationafterdiveType::
  surfaceintervalafterdive (::std::unique_ptr< surfaceintervalafterdive_type > x)
  {
    this->surfaceintervalafterdive_.set (std::move (x));
  }

  const informationafterdiveType::lowesttemperature_optional& informationafterdiveType::
  lowesttemperature () const
  {
    return this->lowesttemperature_;
  }

  informationafterdiveType::lowesttemperature_optional& informationafterdiveType::
  lowesttemperature ()
  {
    return this->lowesttemperature_;
  }

  void informationafterdiveType::
  lowesttemperature (const lowesttemperature_type& x)
  {
    this->lowesttemperature_.set (x);
  }

  void informationafterdiveType::
  lowesttemperature (const lowesttemperature_optional& x)
  {
    this->lowesttemperature_ = x;
  }

  const informationafterdiveType::greatestdepth_type& informationafterdiveType::
  greatestdepth () const
  {
    return this->greatestdepth_.get ();
  }

  informationafterdiveType::greatestdepth_type& informationafterdiveType::
  greatestdepth ()
  {
    return this->greatestdepth_.get ();
  }

  void informationafterdiveType::
  greatestdepth (const greatestdepth_type& x)
  {
    this->greatestdepth_.set (x);
  }

  const informationafterdiveType::visibility_optional& informationafterdiveType::
  visibility () const
  {
    return this->visibility_;
  }

  informationafterdiveType::visibility_optional& informationafterdiveType::
  visibility ()
  {
    return this->visibility_;
  }

  void informationafterdiveType::
  visibility (const visibility_type& x)
  {
    this->visibility_.set (x);
  }

  void informationafterdiveType::
  visibility (const visibility_optional& x)
  {
    this->visibility_ = x;
  }

  const informationafterdiveType::current_optional& informationafterdiveType::
  current () const
  {
    return this->current_;
  }

  informationafterdiveType::current_optional& informationafterdiveType::
  current ()
  {
    return this->current_;
  }

  void informationafterdiveType::
  current (const current_type& x)
  {
    this->current_.set (x);
  }

  void informationafterdiveType::
  current (const current_optional& x)
  {
    this->current_ = x;
  }

  void informationafterdiveType::
  current (::std::unique_ptr< current_type > x)
  {
    this->current_.set (std::move (x));
  }

  const informationafterdiveType::diveplan_optional& informationafterdiveType::
  diveplan () const
  {
    return this->diveplan_;
  }

  informationafterdiveType::diveplan_optional& informationafterdiveType::
  diveplan ()
  {
    return this->diveplan_;
  }

  void informationafterdiveType::
  diveplan (const diveplan_type& x)
  {
    this->diveplan_.set (x);
  }

  void informationafterdiveType::
  diveplan (const diveplan_optional& x)
  {
    this->diveplan_ = x;
  }

  void informationafterdiveType::
  diveplan (::std::unique_ptr< diveplan_type > x)
  {
    this->diveplan_.set (std::move (x));
  }

  const informationafterdiveType::equipmentmalfunction_optional& informationafterdiveType::
  equipmentmalfunction () const
  {
    return this->equipmentmalfunction_;
  }

  informationafterdiveType::equipmentmalfunction_optional& informationafterdiveType::
  equipmentmalfunction ()
  {
    return this->equipmentmalfunction_;
  }

  void informationafterdiveType::
  equipmentmalfunction (const equipmentmalfunction_type& x)
  {
    this->equipmentmalfunction_.set (x);
  }

  void informationafterdiveType::
  equipmentmalfunction (const equipmentmalfunction_optional& x)
  {
    this->equipmentmalfunction_ = x;
  }

  void informationafterdiveType::
  equipmentmalfunction (::std::unique_ptr< equipmentmalfunction_type > x)
  {
    this->equipmentmalfunction_.set (std::move (x));
  }

  const informationafterdiveType::pressuredrop_optional& informationafterdiveType::
  pressuredrop () const
  {
    return this->pressuredrop_;
  }

  informationafterdiveType::pressuredrop_optional& informationafterdiveType::
  pressuredrop ()
  {
    return this->pressuredrop_;
  }

  void informationafterdiveType::
  pressuredrop (const pressuredrop_type& x)
  {
    this->pressuredrop_.set (x);
  }

  void informationafterdiveType::
  pressuredrop (const pressuredrop_optional& x)
  {
    this->pressuredrop_ = x;
  }

  const informationafterdiveType::problems_optional& informationafterdiveType::
  problems () const
  {
    return this->problems_;
  }

  informationafterdiveType::problems_optional& informationafterdiveType::
  problems ()
  {
    return this->problems_;
  }

  void informationafterdiveType::
  problems (const problems_type& x)
  {
    this->problems_.set (x);
  }

  void informationafterdiveType::
  problems (const problems_optional& x)
  {
    this->problems_ = x;
  }

  void informationafterdiveType::
  problems (::std::unique_ptr< problems_type > x)
  {
    this->problems_.set (std::move (x));
  }

  const informationafterdiveType::program_optional& informationafterdiveType::
  program () const
  {
    return this->program_;
  }

  informationafterdiveType::program_optional& informationafterdiveType::
  program ()
  {
    return this->program_;
  }

  void informationafterdiveType::
  program (const program_type& x)
  {
    this->program_.set (x);
  }

  void informationafterdiveType::
  program (const program_optional& x)
  {
    this->program_ = x;
  }

  void informationafterdiveType::
  program (::std::unique_ptr< program_type > x)
  {
    this->program_.set (std::move (x));
  }

  const informationafterdiveType::thermalcomfort_optional& informationafterdiveType::
  thermalcomfort () const
  {
    return this->thermalcomfort_;
  }

  informationafterdiveType::thermalcomfort_optional& informationafterdiveType::
  thermalcomfort ()
  {
    return this->thermalcomfort_;
  }

  void informationafterdiveType::
  thermalcomfort (const thermalcomfort_type& x)
  {
    this->thermalcomfort_.set (x);
  }

  void informationafterdiveType::
  thermalcomfort (const thermalcomfort_optional& x)
  {
    this->thermalcomfort_ = x;
  }

  void informationafterdiveType::
  thermalcomfort (::std::unique_ptr< thermalcomfort_type > x)
  {
    this->thermalcomfort_.set (std::move (x));
  }

  const informationafterdiveType::workload_optional& informationafterdiveType::
  workload () const
  {
    return this->workload_;
  }

  informationafterdiveType::workload_optional& informationafterdiveType::
  workload ()
  {
    return this->workload_;
  }

  void informationafterdiveType::
  workload (const workload_type& x)
  {
    this->workload_.set (x);
  }

  void informationafterdiveType::
  workload (const workload_optional& x)
  {
    this->workload_ = x;
  }

  void informationafterdiveType::
  workload (::std::unique_ptr< workload_type > x)
  {
    this->workload_.set (std::move (x));
  }

  const informationafterdiveType::desaturationtime_optional& informationafterdiveType::
  desaturationtime () const
  {
    return this->desaturationtime_;
  }

  informationafterdiveType::desaturationtime_optional& informationafterdiveType::
  desaturationtime ()
  {
    return this->desaturationtime_;
  }

  void informationafterdiveType::
  desaturationtime (const desaturationtime_type& x)
  {
    this->desaturationtime_.set (x);
  }

  void informationafterdiveType::
  desaturationtime (const desaturationtime_optional& x)
  {
    this->desaturationtime_ = x;
  }

  const informationafterdiveType::noflighttime_optional& informationafterdiveType::
  noflighttime () const
  {
    return this->noflighttime_;
  }

  informationafterdiveType::noflighttime_optional& informationafterdiveType::
  noflighttime ()
  {
    return this->noflighttime_;
  }

  void informationafterdiveType::
  noflighttime (const noflighttime_type& x)
  {
    this->noflighttime_.set (x);
  }

  void informationafterdiveType::
  noflighttime (const noflighttime_optional& x)
  {
    this->noflighttime_ = x;
  }

  const informationafterdiveType::notes_optional& informationafterdiveType::
  notes () const
  {
    return this->notes_;
  }

  informationafterdiveType::notes_optional& informationafterdiveType::
  notes ()
  {
    return this->notes_;
  }

  void informationafterdiveType::
  notes (const notes_type& x)
  {
    this->notes_.set (x);
  }

  void informationafterdiveType::
  notes (const notes_optional& x)
  {
    this->notes_ = x;
  }

  void informationafterdiveType::
  notes (::std::unique_ptr< notes_type > x)
  {
    this->notes_.set (std::move (x));
  }

  const informationafterdiveType::rating_optional& informationafterdiveType::
  rating () const
  {
    return this->rating_;
  }

  informationafterdiveType::rating_optional& informationafterdiveType::
  rating ()
  {
    return this->rating_;
  }

  void informationafterdiveType::
  rating (const rating_type& x)
  {
    this->rating_.set (x);
  }

  void informationafterdiveType::
  rating (const rating_optional& x)
  {
    this->rating_ = x;
  }

  void informationafterdiveType::
  rating (::std::unique_ptr< rating_type > x)
  {
    this->rating_.set (std::move (x));
  }

  const informationafterdiveType::anysymptoms_optional& informationafterdiveType::
  anysymptoms () const
  {
    return this->anysymptoms_;
  }

  informationafterdiveType::anysymptoms_optional& informationafterdiveType::
  anysymptoms ()
  {
    return this->anysymptoms_;
  }

  void informationafterdiveType::
  anysymptoms (const anysymptoms_type& x)
  {
    this->anysymptoms_.set (x);
  }

  void informationafterdiveType::
  anysymptoms (const anysymptoms_optional& x)
  {
    this->anysymptoms_ = x;
  }

  void informationafterdiveType::
  anysymptoms (::std::unique_ptr< anysymptoms_type > x)
  {
    this->anysymptoms_.set (std::move (x));
  }

  const informationafterdiveType::diveduration_type& informationafterdiveType::
  diveduration () const
  {
    return this->diveduration_.get ();
  }

  informationafterdiveType::diveduration_type& informationafterdiveType::
  diveduration ()
  {
    return this->diveduration_.get ();
  }

  void informationafterdiveType::
  diveduration (const diveduration_type& x)
  {
    this->diveduration_.set (x);
  }

  const informationafterdiveType::divetable_optional& informationafterdiveType::
  divetable () const
  {
    return this->divetable_;
  }

  informationafterdiveType::divetable_optional& informationafterdiveType::
  divetable ()
  {
    return this->divetable_;
  }

  void informationafterdiveType::
  divetable (const divetable_type& x)
  {
    this->divetable_.set (x);
  }

  void informationafterdiveType::
  divetable (const divetable_optional& x)
  {
    this->divetable_ = x;
  }

  void informationafterdiveType::
  divetable (::std::unique_ptr< divetable_type > x)
  {
    this->divetable_.set (std::move (x));
  }

  const informationafterdiveType::globalalarmsgiven_optional& informationafterdiveType::
  globalalarmsgiven () const
  {
    return this->globalalarmsgiven_;
  }

  informationafterdiveType::globalalarmsgiven_optional& informationafterdiveType::
  globalalarmsgiven ()
  {
    return this->globalalarmsgiven_;
  }

  void informationafterdiveType::
  globalalarmsgiven (const globalalarmsgiven_type& x)
  {
    this->globalalarmsgiven_.set (x);
  }

  void informationafterdiveType::
  globalalarmsgiven (const globalalarmsgiven_optional& x)
  {
    this->globalalarmsgiven_ = x;
  }

  void informationafterdiveType::
  globalalarmsgiven (::std::unique_ptr< globalalarmsgiven_type > x)
  {
    this->globalalarmsgiven_.set (std::move (x));
  }

  const informationafterdiveType::highestpo2_optional& informationafterdiveType::
  highestpo2 () const
  {
    return this->highestpo2_;
  }

  informationafterdiveType::highestpo2_optional& informationafterdiveType::
  highestpo2 ()
  {
    return this->highestpo2_;
  }

  void informationafterdiveType::
  highestpo2 (const highestpo2_type& x)
  {
    this->highestpo2_.set (x);
  }

  void informationafterdiveType::
  highestpo2 (const highestpo2_optional& x)
  {
    this->highestpo2_ = x;
  }

  const informationafterdiveType::observations_optional& informationafterdiveType::
  observations () const
  {
    return this->observations_;
  }

  informationafterdiveType::observations_optional& informationafterdiveType::
  observations ()
  {
    return this->observations_;
  }

  void informationafterdiveType::
  observations (const observations_type& x)
  {
    this->observations_.set (x);
  }

  void informationafterdiveType::
  observations (const observations_optional& x)
  {
    this->observations_ = x;
  }

  void informationafterdiveType::
  observations (::std::unique_ptr< observations_type > x)
  {
    this->observations_.set (std::move (x));
  }

  const informationafterdiveType::averagedepth_optional& informationafterdiveType::
  averagedepth () const
  {
    return this->averagedepth_;
  }

  informationafterdiveType::averagedepth_optional& informationafterdiveType::
  averagedepth ()
  {
    return this->averagedepth_;
  }

  void informationafterdiveType::
  averagedepth (const averagedepth_type& x)
  {
    this->averagedepth_.set (x);
  }

  void informationafterdiveType::
  averagedepth (const averagedepth_optional& x)
  {
    this->averagedepth_ = x;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace streit
{
  // informationafterdiveType
  //

  informationafterdiveType::
  informationafterdiveType (const greatestdepth_type& greatestdepth,
                            const diveduration_type& diveduration)
  : ::xml_schema::type (),
    surfaceintervalafterdive_ (this),
    lowesttemperature_ (this),
    greatestdepth_ (greatestdepth, this),
    visibility_ (this),
    current_ (this),
    diveplan_ (this),
    equipmentmalfunction_ (this),
    pressuredrop_ (this),
    problems_ (this),
    program_ (this),
    thermalcomfort_ (this),
    workload_ (this),
    desaturationtime_ (this),
    noflighttime_ (this),
    notes_ (this),
    rating_ (this),
    anysymptoms_ (this),
    diveduration_ (diveduration, this),
    divetable_ (this),
    globalalarmsgiven_ (this),
    highestpo2_ (this),
    observations_ (this),
    averagedepth_ (this)
  {
  }

  informationafterdiveType::
  informationafterdiveType (const informationafterdiveType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    surfaceintervalafterdive_ (x.surfaceintervalafterdive_, f, this),
    lowesttemperature_ (x.lowesttemperature_, f, this),
    greatestdepth_ (x.greatestdepth_, f, this),
    visibility_ (x.visibility_, f, this),
    current_ (x.current_, f, this),
    diveplan_ (x.diveplan_, f, this),
    equipmentmalfunction_ (x.equipmentmalfunction_, f, this),
    pressuredrop_ (x.pressuredrop_, f, this),
    problems_ (x.problems_, f, this),
    program_ (x.program_, f, this),
    thermalcomfort_ (x.thermalcomfort_, f, this),
    workload_ (x.workload_, f, this),
    desaturationtime_ (x.desaturationtime_, f, this),
    noflighttime_ (x.noflighttime_, f, this),
    notes_ (x.notes_, f, this),
    rating_ (x.rating_, f, this),
    anysymptoms_ (x.anysymptoms_, f, this),
    diveduration_ (x.diveduration_, f, this),
    divetable_ (x.divetable_, f, this),
    globalalarmsgiven_ (x.globalalarmsgiven_, f, this),
    highestpo2_ (x.highestpo2_, f, this),
    observations_ (x.observations_, f, this),
    averagedepth_ (x.averagedepth_, f, this)
  {
  }

  informationafterdiveType::
  informationafterdiveType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    surfaceintervalafterdive_ (this),
    lowesttemperature_ (this),
    greatestdepth_ (this),
    visibility_ (this),
    current_ (this),
    diveplan_ (this),
    equipmentmalfunction_ (this),
    pressuredrop_ (this),
    problems_ (this),
    program_ (this),
    thermalcomfort_ (this),
    workload_ (this),
    desaturationtime_ (this),
    noflighttime_ (this),
    notes_ (this),
    rating_ (this),
    anysymptoms_ (this),
    diveduration_ (this),
    divetable_ (this),
    globalalarmsgiven_ (this),
    highestpo2_ (this),
    observations_ (this),
    averagedepth_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void informationafterdiveType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // surfaceintervalafterdive
      //
      if (n.name () == "surfaceintervalafterdive" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< surfaceintervalafterdive_type > r (
          surfaceintervalafterdive_traits::create (i, f, this));

        if (!this->surfaceintervalafterdive_)
        {
          this->surfaceintervalafterdive_.set (::std::move (r));
          continue;
        }
      }

      // lowesttemperature
      //
      if (n.name () == "lowesttemperature" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->lowesttemperature_)
        {
          this->lowesttemperature_.set (lowesttemperature_traits::create (i, f, this));
          continue;
        }
      }

      // greatestdepth
      //
      if (n.name () == "greatestdepth" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!greatestdepth_.present ())
        {
          this->greatestdepth_.set (greatestdepth_traits::create (i, f, this));
          continue;
        }
      }

      // visibility
      //
      if (n.name () == "visibility" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->visibility_)
        {
          this->visibility_.set (visibility_traits::create (i, f, this));
          continue;
        }
      }

      // current
      //
      if (n.name () == "current" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< current_type > r (
          current_traits::create (i, f, this));

        if (!this->current_)
        {
          this->current_.set (::std::move (r));
          continue;
        }
      }

      // diveplan
      //
      if (n.name () == "diveplan" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< diveplan_type > r (
          diveplan_traits::create (i, f, this));

        if (!this->diveplan_)
        {
          this->diveplan_.set (::std::move (r));
          continue;
        }
      }

      // equipmentmalfunction
      //
      if (n.name () == "equipmentmalfunction" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< equipmentmalfunction_type > r (
          equipmentmalfunction_traits::create (i, f, this));

        if (!this->equipmentmalfunction_)
        {
          this->equipmentmalfunction_.set (::std::move (r));
          continue;
        }
      }

      // pressuredrop
      //
      if (n.name () == "pressuredrop" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->pressuredrop_)
        {
          this->pressuredrop_.set (pressuredrop_traits::create (i, f, this));
          continue;
        }
      }

      // problems
      //
      if (n.name () == "problems" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< problems_type > r (
          problems_traits::create (i, f, this));

        if (!this->problems_)
        {
          this->problems_.set (::std::move (r));
          continue;
        }
      }

      // program
      //
      if (n.name () == "program" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< program_type > r (
          program_traits::create (i, f, this));

        if (!this->program_)
        {
          this->program_.set (::std::move (r));
          continue;
        }
      }

      // thermalcomfort
      //
      if (n.name () == "thermalcomfort" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< thermalcomfort_type > r (
          thermalcomfort_traits::create (i, f, this));

        if (!this->thermalcomfort_)
        {
          this->thermalcomfort_.set (::std::move (r));
          continue;
        }
      }

      // workload
      //
      if (n.name () == "workload" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< workload_type > r (
          workload_traits::create (i, f, this));

        if (!this->workload_)
        {
          this->workload_.set (::std::move (r));
          continue;
        }
      }

      // desaturationtime
      //
      if (n.name () == "desaturationtime" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->desaturationtime_)
        {
          this->desaturationtime_.set (desaturationtime_traits::create (i, f, this));
          continue;
        }
      }

      // noflighttime
      //
      if (n.name () == "noflighttime" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->noflighttime_)
        {
          this->noflighttime_.set (noflighttime_traits::create (i, f, this));
          continue;
        }
      }

      // notes
      //
      if (n.name () == "notes" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< notes_type > r (
          notes_traits::create (i, f, this));

        if (!this->notes_)
        {
          this->notes_.set (::std::move (r));
          continue;
        }
      }

      // rating
      //
      if (n.name () == "rating" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< rating_type > r (
          rating_traits::create (i, f, this));

        if (!this->rating_)
        {
          this->rating_.set (::std::move (r));
          continue;
        }
      }

      // anysymptoms
      //
      if (n.name () == "anysymptoms" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< anysymptoms_type > r (
          anysymptoms_traits::create (i, f, this));

        if (!this->anysymptoms_)
        {
          this->anysymptoms_.set (::std::move (r));
          continue;
        }
      }

      // diveduration
      //
      if (n.name () == "diveduration" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!diveduration_.present ())
        {
          this->diveduration_.set (diveduration_traits::create (i, f, this));
          continue;
        }
      }

      // divetable
      //
      if (n.name () == "divetable" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< divetable_type > r (
          divetable_traits::create (i, f, this));

        if (!this->divetable_)
        {
          this->divetable_.set (::std::move (r));
          continue;
        }
      }

      // globalalarmsgiven
      //
      if (n.name () == "globalalarmsgiven" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< globalalarmsgiven_type > r (
          globalalarmsgiven_traits::create (i, f, this));

        if (!this->globalalarmsgiven_)
        {
          this->globalalarmsgiven_.set (::std::move (r));
          continue;
        }
      }

      // highestpo2
      //
      if (n.name () == "highestpo2" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->highestpo2_)
        {
          this->highestpo2_.set (highestpo2_traits::create (i, f, this));
          continue;
        }
      }

      // observations
      //
      if (n.name () == "observations" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< observations_type > r (
          observations_traits::create (i, f, this));

        if (!this->observations_)
        {
          this->observations_.set (::std::move (r));
          continue;
        }
      }

      // averagedepth
      //
      if (n.name () == "averagedepth" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->averagedepth_)
        {
          this->averagedepth_.set (averagedepth_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!greatestdepth_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "greatestdepth",
        "http://www.streit.cc/uddf/3.2/");
    }

    if (!diveduration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "diveduration",
        "http://www.streit.cc/uddf/3.2/");
    }
  }

  informationafterdiveType* informationafterdiveType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class informationafterdiveType (*this, f, c);
  }

  informationafterdiveType& informationafterdiveType::
  operator= (const informationafterdiveType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->surfaceintervalafterdive_ = x.surfaceintervalafterdive_;
      this->lowesttemperature_ = x.lowesttemperature_;
      this->greatestdepth_ = x.greatestdepth_;
      this->visibility_ = x.visibility_;
      this->current_ = x.current_;
      this->diveplan_ = x.diveplan_;
      this->equipmentmalfunction_ = x.equipmentmalfunction_;
      this->pressuredrop_ = x.pressuredrop_;
      this->problems_ = x.problems_;
      this->program_ = x.program_;
      this->thermalcomfort_ = x.thermalcomfort_;
      this->workload_ = x.workload_;
      this->desaturationtime_ = x.desaturationtime_;
      this->noflighttime_ = x.noflighttime_;
      this->notes_ = x.notes_;
      this->rating_ = x.rating_;
      this->anysymptoms_ = x.anysymptoms_;
      this->diveduration_ = x.diveduration_;
      this->divetable_ = x.divetable_;
      this->globalalarmsgiven_ = x.globalalarmsgiven_;
      this->highestpo2_ = x.highestpo2_;
      this->observations_ = x.observations_;
      this->averagedepth_ = x.averagedepth_;
    }

    return *this;
  }

  informationafterdiveType::
  ~informationafterdiveType ()
  {
  }
}

#include <ostream>

namespace streit
{
  ::std::ostream&
  operator<< (::std::ostream& o, const informationafterdiveType& i)
  {
    if (i.surfaceintervalafterdive ())
    {
      o << ::std::endl << "surfaceintervalafterdive: " << *i.surfaceintervalafterdive ();
    }

    if (i.lowesttemperature ())
    {
      o << ::std::endl << "lowesttemperature: " << *i.lowesttemperature ();
    }

    o << ::std::endl << "greatestdepth: " << i.greatestdepth ();
    if (i.visibility ())
    {
      o << ::std::endl << "visibility: " << *i.visibility ();
    }

    if (i.current ())
    {
      o << ::std::endl << "current: " << *i.current ();
    }

    if (i.diveplan ())
    {
      o << ::std::endl << "diveplan: " << *i.diveplan ();
    }

    if (i.equipmentmalfunction ())
    {
      o << ::std::endl << "equipmentmalfunction: " << *i.equipmentmalfunction ();
    }

    if (i.pressuredrop ())
    {
      o << ::std::endl << "pressuredrop: " << *i.pressuredrop ();
    }

    if (i.problems ())
    {
      o << ::std::endl << "problems: " << *i.problems ();
    }

    if (i.program ())
    {
      o << ::std::endl << "program: " << *i.program ();
    }

    if (i.thermalcomfort ())
    {
      o << ::std::endl << "thermalcomfort: " << *i.thermalcomfort ();
    }

    if (i.workload ())
    {
      o << ::std::endl << "workload: " << *i.workload ();
    }

    if (i.desaturationtime ())
    {
      o << ::std::endl << "desaturationtime: " << *i.desaturationtime ();
    }

    if (i.noflighttime ())
    {
      o << ::std::endl << "noflighttime: " << *i.noflighttime ();
    }

    if (i.notes ())
    {
      o << ::std::endl << "notes: " << *i.notes ();
    }

    if (i.rating ())
    {
      o << ::std::endl << "rating: " << *i.rating ();
    }

    if (i.anysymptoms ())
    {
      o << ::std::endl << "anysymptoms: " << *i.anysymptoms ();
    }

    o << ::std::endl << "diveduration: " << i.diveduration ();
    if (i.divetable ())
    {
      o << ::std::endl << "divetable: " << *i.divetable ();
    }

    if (i.globalalarmsgiven ())
    {
      o << ::std::endl << "globalalarmsgiven: " << *i.globalalarmsgiven ();
    }

    if (i.highestpo2 ())
    {
      o << ::std::endl << "highestpo2: " << *i.highestpo2 ();
    }

    if (i.observations ())
    {
      o << ::std::endl << "observations: " << *i.observations ();
    }

    if (i.averagedepth ())
    {
      o << ::std::endl << "averagedepth: " << *i.averagedepth ();
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace streit
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

