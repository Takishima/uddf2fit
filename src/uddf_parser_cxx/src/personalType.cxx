// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "personalType.hxx"

#include "sexType.hxx"

#include "encapsulatedDateTimeType.hxx"

#include "membership.hxx"

#include "smoking.hxx"

#include "numberofdives.hxx"

namespace streit
{
  // personalType
  //

  const personalType::firstname_type& personalType::
  firstname () const
  {
    return this->firstname_.get ();
  }

  personalType::firstname_type& personalType::
  firstname ()
  {
    return this->firstname_.get ();
  }

  void personalType::
  firstname (const firstname_type& x)
  {
    this->firstname_.set (x);
  }

  void personalType::
  firstname (::std::unique_ptr< firstname_type > x)
  {
    this->firstname_.set (std::move (x));
  }

  const personalType::middlename_optional& personalType::
  middlename () const
  {
    return this->middlename_;
  }

  personalType::middlename_optional& personalType::
  middlename ()
  {
    return this->middlename_;
  }

  void personalType::
  middlename (const middlename_type& x)
  {
    this->middlename_.set (x);
  }

  void personalType::
  middlename (const middlename_optional& x)
  {
    this->middlename_ = x;
  }

  void personalType::
  middlename (::std::unique_ptr< middlename_type > x)
  {
    this->middlename_.set (std::move (x));
  }

  const personalType::lastname_type& personalType::
  lastname () const
  {
    return this->lastname_.get ();
  }

  personalType::lastname_type& personalType::
  lastname ()
  {
    return this->lastname_.get ();
  }

  void personalType::
  lastname (const lastname_type& x)
  {
    this->lastname_.set (x);
  }

  void personalType::
  lastname (::std::unique_ptr< lastname_type > x)
  {
    this->lastname_.set (std::move (x));
  }

  const personalType::birthname_optional& personalType::
  birthname () const
  {
    return this->birthname_;
  }

  personalType::birthname_optional& personalType::
  birthname ()
  {
    return this->birthname_;
  }

  void personalType::
  birthname (const birthname_type& x)
  {
    this->birthname_.set (x);
  }

  void personalType::
  birthname (const birthname_optional& x)
  {
    this->birthname_ = x;
  }

  void personalType::
  birthname (::std::unique_ptr< birthname_type > x)
  {
    this->birthname_.set (std::move (x));
  }

  const personalType::honorific_optional& personalType::
  honorific () const
  {
    return this->honorific_;
  }

  personalType::honorific_optional& personalType::
  honorific ()
  {
    return this->honorific_;
  }

  void personalType::
  honorific (const honorific_type& x)
  {
    this->honorific_.set (x);
  }

  void personalType::
  honorific (const honorific_optional& x)
  {
    this->honorific_ = x;
  }

  void personalType::
  honorific (::std::unique_ptr< honorific_type > x)
  {
    this->honorific_.set (std::move (x));
  }

  const personalType::sex_optional& personalType::
  sex () const
  {
    return this->sex_;
  }

  personalType::sex_optional& personalType::
  sex ()
  {
    return this->sex_;
  }

  void personalType::
  sex (const sex_type& x)
  {
    this->sex_.set (x);
  }

  void personalType::
  sex (const sex_optional& x)
  {
    this->sex_ = x;
  }

  void personalType::
  sex (::std::unique_ptr< sex_type > x)
  {
    this->sex_.set (std::move (x));
  }

  const personalType::birthdate_optional& personalType::
  birthdate () const
  {
    return this->birthdate_;
  }

  personalType::birthdate_optional& personalType::
  birthdate ()
  {
    return this->birthdate_;
  }

  void personalType::
  birthdate (const birthdate_type& x)
  {
    this->birthdate_.set (x);
  }

  void personalType::
  birthdate (const birthdate_optional& x)
  {
    this->birthdate_ = x;
  }

  void personalType::
  birthdate (::std::unique_ptr< birthdate_type > x)
  {
    this->birthdate_.set (std::move (x));
  }

  const personalType::passport_optional& personalType::
  passport () const
  {
    return this->passport_;
  }

  personalType::passport_optional& personalType::
  passport ()
  {
    return this->passport_;
  }

  void personalType::
  passport (const passport_type& x)
  {
    this->passport_.set (x);
  }

  void personalType::
  passport (const passport_optional& x)
  {
    this->passport_ = x;
  }

  void personalType::
  passport (::std::unique_ptr< passport_type > x)
  {
    this->passport_.set (std::move (x));
  }

  const personalType::membership_optional& personalType::
  membership () const
  {
    return this->membership_;
  }

  personalType::membership_optional& personalType::
  membership ()
  {
    return this->membership_;
  }

  void personalType::
  membership (const membership_type& x)
  {
    this->membership_.set (x);
  }

  void personalType::
  membership (const membership_optional& x)
  {
    this->membership_ = x;
  }

  void personalType::
  membership (::std::unique_ptr< membership_type > x)
  {
    this->membership_.set (std::move (x));
  }

  const personalType::height_optional& personalType::
  height () const
  {
    return this->height_;
  }

  personalType::height_optional& personalType::
  height ()
  {
    return this->height_;
  }

  void personalType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void personalType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  const personalType::weight_optional& personalType::
  weight () const
  {
    return this->weight_;
  }

  personalType::weight_optional& personalType::
  weight ()
  {
    return this->weight_;
  }

  void personalType::
  weight (const weight_type& x)
  {
    this->weight_.set (x);
  }

  void personalType::
  weight (const weight_optional& x)
  {
    this->weight_ = x;
  }

  const personalType::bloodgroup_optional& personalType::
  bloodgroup () const
  {
    return this->bloodgroup_;
  }

  personalType::bloodgroup_optional& personalType::
  bloodgroup ()
  {
    return this->bloodgroup_;
  }

  void personalType::
  bloodgroup (const bloodgroup_type& x)
  {
    this->bloodgroup_.set (x);
  }

  void personalType::
  bloodgroup (const bloodgroup_optional& x)
  {
    this->bloodgroup_ = x;
  }

  void personalType::
  bloodgroup (::std::unique_ptr< bloodgroup_type > x)
  {
    this->bloodgroup_.set (std::move (x));
  }

  const personalType::smoking_optional& personalType::
  smoking () const
  {
    return this->smoking_;
  }

  personalType::smoking_optional& personalType::
  smoking ()
  {
    return this->smoking_;
  }

  void personalType::
  smoking (const smoking_type& x)
  {
    this->smoking_.set (x);
  }

  void personalType::
  smoking (const smoking_optional& x)
  {
    this->smoking_ = x;
  }

  void personalType::
  smoking (::std::unique_ptr< smoking_type > x)
  {
    this->smoking_.set (std::move (x));
  }

  const personalType::numberofdives_optional& personalType::
  numberofdives () const
  {
    return this->numberofdives_;
  }

  personalType::numberofdives_optional& personalType::
  numberofdives ()
  {
    return this->numberofdives_;
  }

  void personalType::
  numberofdives (const numberofdives_type& x)
  {
    this->numberofdives_.set (x);
  }

  void personalType::
  numberofdives (const numberofdives_optional& x)
  {
    this->numberofdives_ = x;
  }

  void personalType::
  numberofdives (::std::unique_ptr< numberofdives_type > x)
  {
    this->numberofdives_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace streit
{
  // personalType
  //

  personalType::
  personalType (const firstname_type& firstname,
                const lastname_type& lastname)
  : ::xml_schema::type (),
    firstname_ (firstname, this),
    middlename_ (this),
    lastname_ (lastname, this),
    birthname_ (this),
    honorific_ (this),
    sex_ (this),
    birthdate_ (this),
    passport_ (this),
    membership_ (this),
    height_ (this),
    weight_ (this),
    bloodgroup_ (this),
    smoking_ (this),
    numberofdives_ (this)
  {
  }

  personalType::
  personalType (const personalType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    firstname_ (x.firstname_, f, this),
    middlename_ (x.middlename_, f, this),
    lastname_ (x.lastname_, f, this),
    birthname_ (x.birthname_, f, this),
    honorific_ (x.honorific_, f, this),
    sex_ (x.sex_, f, this),
    birthdate_ (x.birthdate_, f, this),
    passport_ (x.passport_, f, this),
    membership_ (x.membership_, f, this),
    height_ (x.height_, f, this),
    weight_ (x.weight_, f, this),
    bloodgroup_ (x.bloodgroup_, f, this),
    smoking_ (x.smoking_, f, this),
    numberofdives_ (x.numberofdives_, f, this)
  {
  }

  personalType::
  personalType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    firstname_ (this),
    middlename_ (this),
    lastname_ (this),
    birthname_ (this),
    honorific_ (this),
    sex_ (this),
    birthdate_ (this),
    passport_ (this),
    membership_ (this),
    height_ (this),
    weight_ (this),
    bloodgroup_ (this),
    smoking_ (this),
    numberofdives_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void personalType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // firstname
      //
      if (n.name () == "firstname" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< firstname_type > r (
          firstname_traits::create (i, f, this));

        if (!firstname_.present ())
        {
          this->firstname_.set (::std::move (r));
          continue;
        }
      }

      // middlename
      //
      if (n.name () == "middlename" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< middlename_type > r (
          middlename_traits::create (i, f, this));

        if (!this->middlename_)
        {
          this->middlename_.set (::std::move (r));
          continue;
        }
      }

      // lastname
      //
      if (n.name () == "lastname" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< lastname_type > r (
          lastname_traits::create (i, f, this));

        if (!lastname_.present ())
        {
          this->lastname_.set (::std::move (r));
          continue;
        }
      }

      // birthname
      //
      if (n.name () == "birthname" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< birthname_type > r (
          birthname_traits::create (i, f, this));

        if (!this->birthname_)
        {
          this->birthname_.set (::std::move (r));
          continue;
        }
      }

      // honorific
      //
      if (n.name () == "honorific" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< honorific_type > r (
          honorific_traits::create (i, f, this));

        if (!this->honorific_)
        {
          this->honorific_.set (::std::move (r));
          continue;
        }
      }

      // sex
      //
      if (n.name () == "sex" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< sex_type > r (
          sex_traits::create (i, f, this));

        if (!this->sex_)
        {
          this->sex_.set (::std::move (r));
          continue;
        }
      }

      // birthdate
      //
      if (n.name () == "birthdate" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< birthdate_type > r (
          birthdate_traits::create (i, f, this));

        if (!this->birthdate_)
        {
          this->birthdate_.set (::std::move (r));
          continue;
        }
      }

      // passport
      //
      if (n.name () == "passport" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< passport_type > r (
          passport_traits::create (i, f, this));

        if (!this->passport_)
        {
          this->passport_.set (::std::move (r));
          continue;
        }
      }

      // membership
      //
      if (n.name () == "membership" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< membership_type > r (
          membership_traits::create (i, f, this));

        if (!this->membership_)
        {
          this->membership_.set (::std::move (r));
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->height_)
        {
          this->height_.set (height_traits::create (i, f, this));
          continue;
        }
      }

      // weight
      //
      if (n.name () == "weight" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        if (!this->weight_)
        {
          this->weight_.set (weight_traits::create (i, f, this));
          continue;
        }
      }

      // bloodgroup
      //
      if (n.name () == "bloodgroup" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< bloodgroup_type > r (
          bloodgroup_traits::create (i, f, this));

        if (!this->bloodgroup_)
        {
          this->bloodgroup_.set (::std::move (r));
          continue;
        }
      }

      // smoking
      //
      if (n.name () == "smoking" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< smoking_type > r (
          smoking_traits::create (i, f, this));

        if (!this->smoking_)
        {
          this->smoking_.set (::std::move (r));
          continue;
        }
      }

      // numberofdives
      //
      if (n.name () == "numberofdives" && n.namespace_ () == "http://www.streit.cc/uddf/3.2/")
      {
        ::std::unique_ptr< numberofdives_type > r (
          numberofdives_traits::create (i, f, this));

        if (!this->numberofdives_)
        {
          this->numberofdives_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!firstname_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "firstname",
        "http://www.streit.cc/uddf/3.2/");
    }

    if (!lastname_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lastname",
        "http://www.streit.cc/uddf/3.2/");
    }
  }

  personalType* personalType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class personalType (*this, f, c);
  }

  personalType& personalType::
  operator= (const personalType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->firstname_ = x.firstname_;
      this->middlename_ = x.middlename_;
      this->lastname_ = x.lastname_;
      this->birthname_ = x.birthname_;
      this->honorific_ = x.honorific_;
      this->sex_ = x.sex_;
      this->birthdate_ = x.birthdate_;
      this->passport_ = x.passport_;
      this->membership_ = x.membership_;
      this->height_ = x.height_;
      this->weight_ = x.weight_;
      this->bloodgroup_ = x.bloodgroup_;
      this->smoking_ = x.smoking_;
      this->numberofdives_ = x.numberofdives_;
    }

    return *this;
  }

  personalType::
  ~personalType ()
  {
  }
}

#include <ostream>

namespace streit
{
  ::std::ostream&
  operator<< (::std::ostream& o, const personalType& i)
  {
    o << ::std::endl << "firstname: " << i.firstname ();
    if (i.middlename ())
    {
      o << ::std::endl << "middlename: " << *i.middlename ();
    }

    o << ::std::endl << "lastname: " << i.lastname ();
    if (i.birthname ())
    {
      o << ::std::endl << "birthname: " << *i.birthname ();
    }

    if (i.honorific ())
    {
      o << ::std::endl << "honorific: " << *i.honorific ();
    }

    if (i.sex ())
    {
      o << ::std::endl << "sex: " << *i.sex ();
    }

    if (i.birthdate ())
    {
      o << ::std::endl << "birthdate: " << *i.birthdate ();
    }

    if (i.passport ())
    {
      o << ::std::endl << "passport: " << *i.passport ();
    }

    if (i.membership ())
    {
      o << ::std::endl << "membership: " << *i.membership ();
    }

    if (i.height ())
    {
      o << ::std::endl << "height: " << *i.height ();
    }

    if (i.weight ())
    {
      o << ::std::endl << "weight: " << *i.weight ();
    }

    if (i.bloodgroup ())
    {
      o << ::std::endl << "bloodgroup: " << *i.bloodgroup ();
    }

    if (i.smoking ())
    {
      o << ::std::endl << "smoking: " << *i.smoking ();
    }

    if (i.numberofdives ())
    {
      o << ::std::endl << "numberofdives: " << *i.numberofdives ();
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace streit
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

